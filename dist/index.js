// @bun
var it=60,C=1000,O=60000,et=60,_t=24,ct=86400000,x=2,b=3000;import{rm as T,mkdir as $,writeFile as J}from"fs/promises";import{join as _,basename as K}from"path";import{cwd as Q,exit as V}from"process";var{$:d,build:X,Glob:B}=globalThis.Bun;import{readFile as q,writeFile as z}from"fs/promises";var{Glob:G}=globalThis.Bun;var y=async(n,s)=>{let o=new G("*.html"),t=[];for await(let c of o.scan({cwd:s,absolute:!0}))t.push(c);for(let c of t){let N=await q(c,"utf8");for(let[I,i]of Object.entries(n)){let r=I.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),E=new RegExp(`(<script[^>]+src=["'])(/?(?:.*\\/)?${r})(?:\\.[^."'/]+)?(\\.js)(["'][^>]*>)`,"g");N=N.replace(E,(a,f,p,A,L)=>{return`${f}${i}${L}`})}await z(c,N,"utf8")}};var xt=async({buildDirectory:n="build",assetsDirectory:s,reactDirectory:o,html:t,htmxDirectory:c,tailwind:N})=>{let I=performance.now(),i=Q(),r=_(i,n),E=s&&_(i,s),a=o&&_(i,o,"indexes"),f=o&&_(i,o,"pages"),p=t?.directory?_(i,t.directory):void 0,A=c&&_(i,c);await T(r,{force:!0,recursive:!0}),await $(r),f&&a&&await Z(f,a);let U=[...(a&&await k(a,"*.tsx"))??[]];if(U.length===0)return console.warn("No entry points found, skipping build"),null;let{logs:h,outputs:v}=await X({entrypoints:U,format:"esm",naming:"[dir]/[name].[hash].[ext]",outdir:r,target:"bun"}).catch((e)=>{console.error("Build failed:",e),V(1)});if(h.forEach((e)=>{if(e.level==="error")console.error(e);else if(e.level==="warning")console.warn(e);else if(e.level==="info"||e.level==="debug")console.info(e)}),E&&await d`cp -R ${E} ${r}`,p)await $(_(r,"html")),await d`cp -R ${p} ${_(r)}`;if(A)await $(_(r,"htmx")),await d`cp -R ${A} ${_(r)}`;if(N)await d`tailwindcss -i ${N.input} -o ${_(r,N.output)}`;let R=v.reduce((e,g)=>{let u=g.path;if(u.startsWith(r))u=u.slice(r.length);u=u.replace(/^\/+/,"");let l=u.split("/").pop();if(!l)return e;let M=`.${g.hash}.`;if(!l.includes(M))throw new Error(`Expected hash delimiter ${M} in ${l}`);let[W]=l.split(M);return e[W]="/"+u,e},{});p&&await y(R,p);let m=performance.now()-I,S;if(m<C)S=`${m.toFixed(x)}ms`;else if(m<O)S=`${(m/C).toFixed(x)}s`;else S=`${(m/O).toFixed(x)}m`;return console.log(`Build completed in ${S}`),R},Z=async(n,s)=>{await T(s,{force:!0,recursive:!0}),await $(s);let o=new B("*.*"),t=[];for await(let N of o.scan({cwd:n}))t.push(N);let c=t.map(async(N)=>{let I=K(N),[i]=I.split("."),r=["import { hydrateRoot } from 'react-dom/client';",`import { ${i} } from '../pages/${i}';
`,`hydrateRoot(document, <${i} />);`].join(`
`);return J(_(s,`${i}Index.tsx`),r)});await Promise.all(c)},k=async(n,s)=>{let o=[],t=new B(s);for await(let c of t.scan({absolute:!0,cwd:n}))o.push(c);return o};import{createElement as F}from"react";import{renderToReadableStream as tt}from"react-dom/server.browser";var Mt=async(n,s)=>{let o=F(n),t=await tt(o,{bootstrapModules:[s]});return new Response(t,{headers:{"Content-Type":"text/html"}})},Ct=(n)=>Bun.file(n);import{argv as nt}from"process";var{env:j}=globalThis.Bun;import ot from"os";var H=()=>{let n=ot.networkInterfaces(),o=Object.values(n).flat().filter((t)=>t!==void 0).find((t)=>t.family==="IPv4"&&!t.internal);if(o)return o.address;return console.warn("No IP address found, falling back to localhost"),"localhost"};var D=j.HOST??"localhost",w=j.PORT??b,P,rt=nt,Y=rt.includes("--host");if(Y)P=H(),D="0.0.0.0";var Ht=(n)=>n.listen({hostname:D,port:w},()=>{if(Y)console.log(`Server started on http://localhost:${w}`),console.log(`Server started on network: http://${P}:${w}`);else console.log(`Server started on http://${D}:${w}`)});export{y as updateScriptTags,Ht as networkingPlugin,Mt as handleReactPageRequest,Ct as handleHTMLPageRequest,H as getLocalIPAddress,xt as build,x as TIME_PRECISION,it as SECONDS_IN_A_MINUTE,et as MINUTES_IN_AN_HOUR,C as MILLISECONDS_IN_A_SECOND,O as MILLISECONDS_IN_A_MINUTE,ct as MILLISECONDS_IN_A_DAY,_t as HOURS_IN_A_DAY,b as DEFAULT_PORT};
