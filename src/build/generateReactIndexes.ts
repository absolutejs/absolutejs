import { mkdir, rm, writeFile } from 'fs/promises';
import { basename, join } from 'path';
import { Glob } from 'bun';

export const generateReactIndexFiles = async (
	reactPagesDirectory: string,
	reactIndexesDirectory: string
) => {
	await rm(reactIndexesDirectory, { force: true, recursive: true });
	await mkdir(reactIndexesDirectory);

	const pagesGlob = new Glob('*.*');
	const files: string[] = [];
	for await (const file of pagesGlob.scan({ cwd: reactPagesDirectory })) {
		files.push(file);
	}
	const promises = files.map(async (file) => {
		const fileName = basename(file);
		const [componentName] = fileName.split('.');
		const content = [
			`import * as React from 'react';`,
			`import * as ReactDOMClient from 'react-dom/client';`,
			`import { hydrateRoot, createRoot } from 'react-dom/client';`,
			`import { createElement } from 'react';`,
			`import type { ComponentType } from 'react'`,
			`import { ${componentName} } from '../pages/${componentName}';\n`,
			`// Expose React on window for HMR (ensures same instance is used)`,
			`if (typeof window !== 'undefined') {`,
			`\twindow.React = React;`,
			`\twindow.ReactDOM = ReactDOMClient;`,
			`}\n`,
			`type PropsOf<C> = C extends ComponentType<infer P> ? P : never;\n`,
			`declare global {`,
			`\tinterface Window {`,
			`\t\t__INITIAL_PROPS__: PropsOf<typeof ${componentName}>`,
			`\t\t__REACT_ROOT__?: ReturnType<typeof hydrateRoot | typeof createRoot>`,
			`\t\t__HMR_CLIENT_ONLY_MODE__?: boolean`,
			`\t}`,
			`}\n`,
			`// Hydration with error handling and fallback`,
			`// For HMR, we're always in development mode`,
			`const isDev = true;`,
			`const componentPath = '../pages/${componentName}';\n`,
			`function isHydrationError(error) {`,
			`\tif (!error) return false;`,
			`\tconst errorMessage = error instanceof Error ? error.message : String(error);`,
			`\tconst errorString = String(error);`,
			`\tconst fullMessage = errorMessage + ' ' + errorString;`,
			`\tconst hydrationKeywords = ['hydration', 'Hydration', 'mismatch', 'Mismatch', 'did not match', 'server rendered HTML', 'server HTML', 'client HTML', 'Hydration failed'];`,
			`\tconst isHydration = hydrationKeywords.some(keyword => fullMessage.includes(keyword));`,
			`\t`,
			`\t// Ignore whitespace-only mismatches in <head> - these are harmless formatting differences`,
			`\t// The error often shows: + <link...> vs - {"\\n            "} which is just formatting`,
			`\tif (isHydration) {`,
			`\t\t// Check if this is a head/link/stylesheet related mismatch`,
			`\t\tconst isHeadRelated = fullMessage.includes('<head') || fullMessage.includes('</head>') || fullMessage.includes('head>') || fullMessage.includes('<link') || fullMessage.includes('link>') || fullMessage.includes('stylesheet') || fullMessage.includes('fonts.googleapis') || fullMessage.includes('rel="stylesheet"');`,
			`\t\t`,
			`\t\t// Check if the mismatch involves only whitespace/newlines`,
			`\t\t// Pattern: looks for {"\\n"} or {"\\n            "} or similar whitespace-only content`,
			`\t\t// Also check for patterns like: - {"\\n            "} or + <link...>`,
			`\t\tconst hasWhitespacePattern = /\\{\\s*["']\\\\n[^"']*["']\\s*\\}/.test(fullMessage) || /\\{\\s*["'][\\\\n\\\\r\\\\s]+["']\\s*\\}/.test(fullMessage) || /-\\s*\\{\\s*["'][\\\\n\\\\r\\\\s]+["']\\s*\\}/.test(fullMessage);`,
			`\t\tconst isWhitespaceOnly = /^[\\s\\n\\r]*$/.test(errorString) || /^[\\s\\n\\r]*$/.test(errorMessage);`,
			`\t\tconst hasNewlinePattern = fullMessage.includes('\\\\n') || fullMessage.includes('\\\\r') || fullMessage.includes('\\n') || fullMessage.includes('\\r');`,
			`\t\t`,
			`\t\t// If it's head-related and involves whitespace/newlines, ignore it`,
			`\t\tif (isHeadRelated && (hasWhitespacePattern || isWhitespaceOnly || hasNewlinePattern)) {`,
			`\t\t\tconsole.warn('‚ö†Ô∏è Ignoring whitespace-only hydration mismatch in <head> (harmless formatting difference)');`,
			`\t\t\tconsole.warn('   This is caused by JSX formatting differences between server and client builds.');`,
			`\t\t\tconsole.warn('   The content is identical, only whitespace differs.');`,
			`\t\t\treturn false; // Don't treat whitespace-only head mismatches as errors`,
			`\t\t}`,
			`\t}`,
			`\treturn isHydration;`,
			`}\n`,
			`function logHydrationError(error, componentName) {`,
			`\tif (!isDev) return;`,
			`\tconsole.group('‚ö†Ô∏è Hydration Mismatch Detected');`,
			`\tconsole.error('Component:', componentName);`,
			`\tconsole.error('File:', componentPath);`,
			`\tconsole.error('Error:', error);`,
			`\tconsole.warn('Falling back to client-only render (no hydration)');`,
			`\tconsole.groupEnd();`,
			`\t`,
			`\t// Report to HMR server if available`,
			`\tif (window.__HMR_WS__ && window.__HMR_WS__.readyState === WebSocket.OPEN) {`,
			`\t\ttry {`,
			`\t\t\twindow.__HMR_WS__.send(JSON.stringify({`,
			`\t\t\t\ttype: 'hydration-error',`,
			`\t\t\t\tdata: {`,
			`\t\t\t\t\tcomponentName: '${componentName}',`,
			`\t\t\t\t\tcomponentPath: componentPath,`,
			`\t\t\t\t\terror: error instanceof Error ? error.message : String(error),`,
			`\t\t\t\t\ttimestamp: Date.now()`,
			`\t\t\t\t}`,
			`\t\t\t}));`,
			`\t\t} catch (err) {`,
			`\t\t\t// Silently fail - reporting is optional`,
			`\t\t}`,
			`\t}`,
			`}\n`,
			`// Track if we've already switched to client-only mode`,
			`let hasSwitchedToClientOnly = false;`,
			`let hydrationErrorDetected = false;\n`,
			`function handleHydrationFallback(error) {`,
			`\tif (hasSwitchedToClientOnly) return; // Already handled`,
			`\thasSwitchedToClientOnly = true;`,
			`\thydrationErrorDetected = true;\n`,
			`\tlogHydrationError(error, '${componentName}');\n`,
			`\t// Fallback: client-only render (no hydration)`,
			`\ttry {`,
			`\t\t// Unmount existing root if it exists`,
			`\t\tif (window.__REACT_ROOT__ && typeof window.__REACT_ROOT__.unmount === 'function') {`,
			`\t\t\ttry {`,
			`\t\t\twindow.__REACT_ROOT__.unmount();`,
			`\t\t\t} catch (e) {`,
			`\t\t\t\t// Ignore unmount errors`,
			`\t\t\t}`,
			`\t\t}\n`,
			`\t\t// Render into the same root container when falling back to client-only`,
			`\t\tconst root = createRoot(container);`,
			`\t\troot.render(createElement(HMRWrapper, mergedProps));`,
			`\t\twindow.__REACT_ROOT__ = root;`,
			`\t\twindow.__HMR_CLIENT_ONLY_MODE__ = true;\n`,
			`\t\tconsole.log('‚úÖ Switched to client-only render mode');`,
			`\t} catch (fallbackError) {`,
			`\t\tconsole.error('‚ùå Failed to fallback to client-only render:', fallbackError);`,
			`\t\t// If client-only rendering fails, reload the page as last resort`,
			`\t\tconsole.warn('‚ö†Ô∏è Reloading page as last resort...');`,
			`\t\twindow.location.reload();`,
			`\t}`,
			`}\n`,
			`// HMR State Preservation: Check for preserved state and merge with initial props`,
			`// This allows state to be preserved across HMR updates without modifying component files`,
			`let preservedState = (typeof window !== 'undefined' && window.__HMR_PRESERVED_STATE__) ? window.__HMR_PRESERVED_STATE__ : {};\n`,
			`// Also check sessionStorage for state that survived a page reload (for React HMR)`,
			`if (typeof window !== 'undefined' && typeof sessionStorage !== 'undefined') {`,
			`\tconst hmrStateJson = sessionStorage.getItem('__REACT_HMR_STATE__');`,
			`\tif (hmrStateJson) {`,
			`\t\ttry {`,
			`\t\t\tconst hmrState = JSON.parse(hmrStateJson);`,
			`\t\t\tconsole.log('üîÑ Restoring React state from sessionStorage:', hmrState);`,
			`\t\t\tpreservedState = { ...preservedState, ...hmrState };`,
			`\t\t\t// Clear the saved state after restoring`,
			`\t\t\tsessionStorage.removeItem('__REACT_HMR_STATE__');`,
			`\t\t} catch (e) {`,
			`\t\t\tconsole.warn('‚ö†Ô∏è Failed to parse HMR state:', e);`,
			`\t\t}`,
			`\t}`,
			`}\n`,
			`const mergedProps = { ...(window.__INITIAL_PROPS__ || {}), ...preservedState };`,
			`// Clear preserved state after using it (so it doesn't persist across multiple updates)`,
			`if (typeof window !== 'undefined') {`,
			`\twindow.__HMR_PRESERVED_STATE__ = undefined;`,
			`}\n`,
			`// Create a wrapper component that forces remount when props change (for HMR state preservation)`,
			`// This ensures useState gets the new initialCount value on remount`,
			`function HMRWrapper(props) {`,
			`\t// Use a key based on preserved state to force remount when state changes`,
			`\tconst stateKey = preservedState && Object.keys(preservedState).length > 0 ? JSON.stringify(preservedState) : 'default';`,
			`\treturn createElement(${componentName}, { ...props, key: stateKey });`,
			`}\n`,
			`// Attempt hydration with error handling`,
			`const container = typeof document !== 'undefined' ? document.getElementById('root') : null;`,
			`if (!container) {`,
			`\tthrow new Error('React root container #root not found in document');`,
			`}\n`,
			`let root;`,
			`try {`,
			`\t// Use onRecoverableError to catch hydration errors (React 19)`,
			`\t// Use HMRWrapper to ensure component remounts with preserved state`,
			`\troot = hydrateRoot(`,
			`\t\tcontainer,`,
			`\t\tcreateElement(HMRWrapper, mergedProps),`,
			`\t\t{`,
			`\t\t\tonRecoverableError: (error) => {`,
			`\t\t\t\t// Check if this is a hydration error (isHydrationError filters out whitespace-only head mismatches)`,
			`\t\t\t\tif (isDev && isHydrationError(error)) {`,
			`\t\t\t\t\t// Real hydration error - handle it`,
			`\t\t\t\t\thandleHydrationFallback(error);`,
			`\t\t\t\t} else {`,
			`\t\t\t\t\t// Not a hydration error, or it's a whitespace-only mismatch that was filtered out`,
			`\t\t\t\t\t// Check if it's a whitespace-only head mismatch using the same logic as isHydrationError`,
			`\t\t\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);`,
			`\t\t\t\t\tconst errorString = String(error);`,
			`\t\t\t\t\tconst fullMessage = errorMessage + ' ' + errorString;`,
			`\t\t\t\t\tconst hydrationKeywords = ['hydration', 'Hydration', 'mismatch', 'Mismatch', 'did not match', 'server rendered HTML', 'server HTML', 'client HTML', 'Hydration failed'];`,
			`\t\t\t\t\tconst isHydration = hydrationKeywords.some(keyword => fullMessage.includes(keyword));`,
			`\t\t\t\t\tif (isHydration) {`,
			`\t\t\t\t\t\t// Check if this is a head/link/stylesheet related mismatch`,
			`\t\t\t\t\t\tconst isHeadRelated = fullMessage.includes('<head') || fullMessage.includes('</head>') || fullMessage.includes('head>') || fullMessage.includes('<link') || fullMessage.includes('link>') || fullMessage.includes('stylesheet') || fullMessage.includes('fonts.googleapis') || fullMessage.includes('rel="stylesheet"');`,
			`\t\t\t\t\t\t// Check if the mismatch involves only whitespace/newlines`,
			`\t\t\t\t\t\tconst hasWhitespacePattern = /\\{\\s*["']\\\\n[^"']*["']\\s*\\}/.test(fullMessage) || /\\{\\s*["'][\\\\n\\\\r\\\\s]+["']\\s*\\}/.test(fullMessage) || /-\\s*\\{\\s*["'][\\\\n\\\\r\\\\s]+["']\\s*\\}/.test(fullMessage);`,
			`\t\t\t\t\t\tconst isWhitespaceOnly = /^[\\s\\n\\r]*$/.test(errorString) || /^[\\s\\n\\r]*$/.test(errorMessage);`,
			`\t\t\t\t\t\tconst hasNewlinePattern = fullMessage.includes('\\\\n') || fullMessage.includes('\\\\r') || fullMessage.includes('\\n') || fullMessage.includes('\\r');`,
			`\t\t\t\t\t\t// If it's head-related and involves whitespace/newlines, silently ignore it`,
			`\t\t\t\t\t\tif (isHeadRelated && (hasWhitespacePattern || isWhitespaceOnly || hasNewlinePattern)) {`,
			`\t\t\t\t\t\t\t// Already logged by isHydrationError, just return silently`,
			`\t\t\t\t\t\t\treturn;`,
			`\t\t\t\t\t\t}`,
			`\t\t\t\t\t}`,
			`\t\t\t\t\t// Log other recoverable errors`,
			`\t\t\t\t\tconsole.error('React recoverable error:', error);`,
			`\t\t\t\t}`,
			`\t\t\t}`,
			`\t\t}`,
			`\t);`,
			`\twindow.__REACT_ROOT__ = root;`,
			`} catch (error) {`,
			`\t// Catch synchronous errors (shouldn't happen with hydrateRoot, but safety net)`,
			`\tif (isDev && isHydrationError(error)) {`,
			`\t\thandleHydrationFallback(error);`,
			`\t} else {`,
			`\t\tthrow error;`,
			`\t}`,
			`}\n`,
			`// Also listen for hydration errors via console.error (React logs them there)`,
			`if (isDev) {`,
			`\tconst originalError = console.error;`,
			`\tconsole.error = function(...args) {`,
			`\t\tconst errorMessage = args.map(arg => {`,
			`\t\t\tif (arg instanceof Error) return arg.message;`,
			`\t\t\treturn String(arg);`,
			`\t\t}).join(' ');`,
			`\t\t`,
			`\t\t// Check if this is a hydration error`,
			`\t\tif (isHydrationError({ message: errorMessage }) && !hydrationErrorDetected) {`,
			`\t\t\thydrationErrorDetected = true;`,
			`\t\t\t// Create a synthetic error for fallback`,
			`\t\t\tconst syntheticError = new Error(errorMessage);`,
			`\t\t\t// Use setTimeout to ensure this happens after React's error handling`,
			`\t\t\tsetTimeout(() => {`,
			`\t\t\t\thandleHydrationFallback(syntheticError);`,
			`\t\t\t}, 0);`,
			`\t\t}`,
			`\t\t`,
			`\t\t// Call original console.error`,
			`\t\toriginalError.apply(console, args);`,
			`\t};`,
			`}`
		].join('\n');

		return writeFile(
			join(reactIndexesDirectory, `${componentName}.tsx`),
			content
		);
	});
	await Promise.all(promises);
};
